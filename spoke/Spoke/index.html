<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Spoke (spoke.Spoke)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">spoke</a> &#x00BB; Spoke</nav><header class="odoc-preamble"><h1>Module <code><span>Spoke</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#spoke,-an-implementation-of-spake2+ee-in-ocaml.">Spoke, an implementation of SPAKE2+EE in OCaml.</a><ul><li><a href="#the-handshake.">The Handshake.</a></li><li><a href="#parameters.">Parameters.</a></li><li><a href="#order-of-primities.">Order of primities.</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="spoke,-an-implementation-of-spake2+ee-in-ocaml."><a href="#spoke,-an-implementation-of-spake2+ee-in-ocaml." class="anchor"></a>Spoke, an implementation of SPAKE2+EE in OCaml.</h2><p>Spoke is an implementation of SPAKE2+EE, a Password-Authenticated Key Agreement. It permits to find an agreement between two people who share a weak password with a strong key via an exchange of few information. From the shared strong key, 2 people can initiate a communication via, for example, a symmetric cryptographic method such as GCM or ChaCha20 Poly1305.</p><p>This module wants to implement the necessary cryptographic primitives for this agreement.</p><h3 id="the-handshake."><a href="#the-handshake." class="anchor"></a>The Handshake.</h3><p>We identify 2 persons, a <code>server</code> and a <code>client</code>. The server will generate some values and a <i>salt</i> and send it to the client with <a href="#val-generate"><code>generate</code></a>. 2 values are then generated, <a href="#type-secret"><code>secret</code></a> and <a href="#type-public"><code>public</code></a>. The first must be strictly known only by the server. The second must be transferred to the client.</p><p>The client can manipulate <code>public</code> with <a href="#val-hello"><code>hello</code></a> and generate a value to be passed to the server. The value is named <code>X</code>. <a href="#val-hello"><code>hello</code></a> returns a <a href="#type-client"><code>client</code></a> value which must be kept by the client.</p><p>The server can then manipulate this received value with <a href="#val-server_compute"><code>server_compute</code></a> to produce 2 values (which can be concatenated) to send to the client. These values are: <code>Y</code> and <code>client_validator</code>. The first participates to the handshake, the second checks the shared key on the client side. <a href="#val-server_compute"><code>server_compute</code></a> returns a <a href="#type-server"><code>server</code></a> which must be kept by the server and used later.</p><p>The client can finalise the agreement with <a href="#val-client_compute"><code>client_compute</code></a> by finally calculating the <code>type:shared_keys</code>. It requires the <code>Y</code> value and the <code>client_validator</code> value as well as the <a href="#type-client"><code>client</code></a> value returned previously. It will then send a final value to ensure that the server can correctly produce the said shared key. The name of this value is the <code>server_validator</code>.</p><p>Finally, the server can commit the agreement by checking the value transmitted by the client as well as the <a href="#type-server"><code>server</code></a> value generated previously and in turn generating the shared key.</p><h3 id="parameters."><a href="#parameters." class="anchor"></a>Parameters.</h3><p>The user is able to choose:</p><ul><li>the <code>KDF</code> function used to generate values (see <a href="#type-algorithm"><code>algorithm</code></a>)</li><li>an argument which will be used by the chosen algorithm</li><li><a href="#type-cipher"><code>cipher</code></a>s which will be used by the client and the server</li><li>tha <a href="#type-hash"><code>hash</code></a> algorithm used to craft internal values</li></ul><h3 id="order-of-primities."><a href="#order-of-primities." class="anchor"></a>Order of primities.</h3><p>Following the handshake explanation above, here is an example of the order in which the primitives should be executed:</p><pre><code>let run ~password =
  let secret, public = Spoke.generate ~password ~algorithm:Pbkdf2 16 in
  let+ client, _X = Spoke.hello ~public password in
  let+ server, (_Y, client_validator) = Spoke.server_compute ~secret
    ~identity:(&quot;Bob&quot;, &quot;Alice&quot;) _X in
  let+ sk0, server_validator = Spoke.client_compute ~client
    ~identity:(&quot;Bob&quot;, &quot;Alice&quot;) _Y client_validator in
  let+ sk1 = Spoke.server_finalize ~server server_validator in
  assert (sk0 = sk1)</code></pre><div class="odoc-spec"><div class="spec type" id="type-client" class="anchored"><a href="#type-client" class="anchor"></a><code><span><span class="keyword">type</span> client</span></code></div><div class="spec-doc"><p>The type of a client.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-server" class="anchored"><a href="#type-server" class="anchor"></a><code><span><span class="keyword">type</span> server</span></code></div><div class="spec-doc"><p>The type of a server.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-hash" class="anchored"><a href="#type-hash" class="anchor"></a><code><span><span class="keyword">type</span> hash</span><span> = </span></code><table><tr id="type-hash.Hash" class="anchored"><td class="def variant constructor"><a href="#type-hash.Hash" class="anchor"></a><code><span>| </span><span><span class="constructor">Hash</span> : <span><span class="type-var">'k</span> <span class="xref-unresolved">Digestif</span>.hash</span> <span class="arrow">&#45;&gt;</span> <a href="#type-hash">hash</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The hash algorithm.</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-algorithm" class="anchored"><a href="#type-algorithm" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a algorithm</span></span><span> = </span></code><table><tr id="type-algorithm.Pbkdf2" class="anchored"><td class="def variant constructor"><a href="#type-algorithm.Pbkdf2" class="anchor"></a><code><span>| </span><span><span class="constructor">Pbkdf2</span> : <span>int <a href="#type-algorithm">algorithm</a></span></span></code></td></tr></table></div><div class="spec-doc"><p>The <code>KDF</code> (Key Derivation Function) used to generate common informations between client &amp; server.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-aead" class="anchored"><a href="#type-aead" class="anchor"></a><code><span><span class="keyword">type</span> <span>_ aead</span></span><span> = </span></code><table><tr id="type-aead.GCM" class="anchored"><td class="def variant constructor"><a href="#type-aead.GCM" class="anchor"></a><code><span>| </span><span><span class="constructor">GCM</span> : <span><span class="xref-unresolved">Mirage_crypto</span>.Cipher_block.AES.GCM.key <a href="#type-aead">aead</a></span></span></code></td></tr><tr id="type-aead.CCM" class="anchored"><td class="def variant constructor"><a href="#type-aead.CCM" class="anchor"></a><code><span>| </span><span><span class="constructor">CCM</span> : <span><span class="xref-unresolved">Mirage_crypto</span>.Cipher_block.AES.CCM.key <a href="#type-aead">aead</a></span></span></code></td></tr><tr id="type-aead.ChaCha20_Poly1305" class="anchored"><td class="def variant constructor"><a href="#type-aead.ChaCha20_Poly1305" class="anchor"></a><code><span>| </span><span><span class="constructor">ChaCha20_Poly1305</span> : <span><span class="xref-unresolved">Mirage_crypto</span>.Chacha20.key <a href="#type-aead">aead</a></span></span></code></td></tr></table></div><div class="spec-doc"><p>The type of Authenticated Encryptions with Associated Data.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-cipher" class="anchored"><a href="#type-cipher" class="anchor"></a><code><span><span class="keyword">type</span> cipher</span><span> = </span></code><table><tr id="type-cipher.AEAD" class="anchored"><td class="def variant constructor"><a href="#type-cipher.AEAD" class="anchor"></a><code><span>| </span><span><span class="constructor">AEAD</span> : <span><span class="type-var">'k</span> <a href="#type-aead">aead</a></span> <span class="arrow">&#45;&gt;</span> <a href="#type-cipher">cipher</a></span></code></td></tr></table></div><div class="spec-doc"><p>The type of ciphers.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-public" class="anchored"><a href="#type-public" class="anchor"></a><code><span><span class="keyword">type</span> public</span></code></div><div class="spec-doc"><p>The type of the public part of the handshake.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-secret" class="anchored"><a href="#type-secret" class="anchor"></a><code><span><span class="keyword">type</span> secret</span></code></div><div class="spec-doc"><p>The type of the secret part of the handshake.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-shared_keys" class="anchored"><a href="#type-shared_keys" class="anchor"></a><code><span><span class="keyword">type</span> shared_keys</span><span> = string * string</span></code></div><div class="spec-doc"><p>The type of shared keys.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-error" class="anchored"><a href="#type-error" class="anchor"></a><code><span><span class="keyword">type</span> error</span><span> = </span><span>[ </span></code><table><tr id="type-error.Point_is_not_on_prime_order_subgroup" class="anchored"><td class="def constructor"><a href="#type-error.Point_is_not_on_prime_order_subgroup" class="anchor"></a><code><span>| </span></code><code><span>`Point_is_not_on_prime_order_subgroup</span></code></td></tr><tr id="type-error.Invalid_client_validator" class="anchored"><td class="def constructor"><a href="#type-error.Invalid_client_validator" class="anchor"></a><code><span>| </span></code><code><span>`Invalid_client_validator</span></code></td></tr><tr id="type-error.Invalid_server_validator" class="anchored"><td class="def constructor"><a href="#type-error.Invalid_server_validator" class="anchor"></a><code><span>| </span></code><code><span>`Invalid_server_validator</span></code></td></tr><tr id="type-error.Invalid_public_packet" class="anchored"><td class="def constructor"><a href="#type-error.Invalid_public_packet" class="anchor"></a><code><span>| </span></code><code><span>`Invalid_public_packet</span></code></td></tr><tr id="type-error.Invalid_secret_packet" class="anchored"><td class="def constructor"><a href="#type-error.Invalid_secret_packet" class="anchor"></a><code><span>| </span></code><code><span>`Invalid_secret_packet</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type of errors.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_error" class="anchored"><a href="#val-pp_error" class="anchor"></a><code><span><span class="keyword">val</span> pp_error : <span><a href="#type-error">error</a> <span class="xref-unresolved">Fmt</span>.t</span></span></code></div><div class="spec-doc"><p>The pretty-printer of <a href="#type-error"><code>error</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-version" class="anchored"><a href="#val-version" class="anchor"></a><code><span><span class="keyword">val</span> version : int</span></code></div><div class="spec-doc"><p>The version of the handshake.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-generate" class="anchored"><a href="#val-generate" class="anchor"></a><code><span><span class="keyword">val</span> generate : 
  <span>?hash:<a href="#type-hash">hash</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?ciphers:<span>(<a href="#type-cipher">cipher</a> * <a href="#type-cipher">cipher</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?g:<span class="xref-unresolved">Stdlib</span>.Random.State.t <span class="arrow">&#45;&gt;</span></span>
  <span>password:string <span class="arrow">&#45;&gt;</span></span>
  <span>algorithm:<span><span class="type-var">'a</span> <a href="#type-algorithm">algorithm</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-secret">secret</a> * <a href="#type-public">public</a></span></code></div><div class="spec-doc"><p><code>generate ?hash ?ciphers ?g ~password ~algorithm v</code> generates the <a href="#type-public"><code>public</code></a> and the <a href="#type-secret"><code>secret</code></a> informations used to handle the handshake for a server.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-public_to_string" class="anchored"><a href="#val-public_to_string" class="anchor"></a><code><span><span class="keyword">val</span> public_to_string : <span><a href="#type-public">public</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>public_to_string public</code> serializes the <a href="#type-public"><code>public</code></a> information into bytes. Therefore, the public information can be transmitted to a client throught a (secured?) channel.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-public_of_string" class="anchored"><a href="#val-public_of_string" class="anchor"></a><code><span><span class="keyword">val</span> public_of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-public">public</a>, <span>[&gt; <a href="#type-error">error</a> ]</span> )</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>public_of_string str</code> tries to deserialize a serie of bytes to a public information.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ciphers_of_public" class="anchored"><a href="#val-ciphers_of_public" class="anchor"></a><code><span><span class="keyword">val</span> ciphers_of_public : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-cipher">cipher</a> * <a href="#type-cipher">cipher</a>, <span>[&gt; <a href="#type-error">error</a> ]</span> )</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>ciphers_of_public str</code> returns ciphers announced by the <a href="#type-public"><code>public</code></a> information serialized.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ciphers_of_client" class="anchored"><a href="#val-ciphers_of_client" class="anchor"></a><code><span><span class="keyword">val</span> ciphers_of_client : <span><a href="#type-client">client</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-cipher">cipher</a> * <a href="#type-cipher">cipher</a></span></code></div><div class="spec-doc"><p><code>ciphers_of_client client</code> returns ciphers from a <a href="#type-client"><code>client</code></a> value.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ciphers_of_secret" class="anchored"><a href="#val-ciphers_of_secret" class="anchor"></a><code><span><span class="keyword">val</span> ciphers_of_secret : <span><a href="#type-secret">secret</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-cipher">cipher</a> * <a href="#type-cipher">cipher</a></span></code></div><div class="spec-doc"><p><code>ciphers_of_secret secret</code> returns ciphers from a <a href="#type-secret"><code>secret</code></a> value.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">[Invalid_argument]</span> <p>if the <code>secret</code> value is malformed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-public_of_secret" class="anchored"><a href="#val-public_of_secret" class="anchor"></a><code><span><span class="keyword">val</span> public_of_secret : <span><a href="#type-secret">secret</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-public">public</a></span></code></div><div class="spec-doc"><p><code>public_of_secret secret</code> regenerates <a href="#type-public"><code>public</code></a> from <a href="#type-secret"><code>secret</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hello" class="anchored"><a href="#val-hello" class="anchor"></a><code><span><span class="keyword">val</span> hello : 
  <span>?g:<span class="xref-unresolved">Stdlib</span>.Random.State.t <span class="arrow">&#45;&gt;</span></span>
  <span>public:string <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <a href="#type-client">client</a> * string, <span>[&gt; <a href="#type-error">error</a> ]</span> )</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>hello ?g ~public password</code> tries to create a <a href="#type-client"><code>client</code></a> information from a serialized <a href="#type-public"><code>public</code></a> one and a <code>password</code>. It generates a curve point which should be transmitted to the server.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-server_compute" class="anchored"><a href="#val-server_compute" class="anchor"></a><code><span><span class="keyword">val</span> server_compute : 
  <span>?g:<span class="xref-unresolved">Stdlib</span>.Random.State.t <span class="arrow">&#45;&gt;</span></span>
  <span>secret:<a href="#type-secret">secret</a> <span class="arrow">&#45;&gt;</span></span>
  <span>identity:<span>(string * string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <a href="#type-server">server</a> * <span>(string * string)</span>, <span>[&gt; <a href="#type-error">error</a> ]</span> )</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>server_compute ?g ~secret ~identity:(client, server) _X</code> tries to validate <code>_X</code> with the given <a href="#type-secret"><code>secret</code></a> information and identities. It returns a <a href="#type-server"><code>server</code></a> information if it succeed as well as a curve point <code>_Y</code> and a <i>client validator</i>. <code>_Y</code> and <code>client_validator</code> should be transmitted to the client.</p><p><b>NOTE</b>: identities is something known to both parties. The client must recognise the server with a unique identifier (like <code>&quot;Bob&quot;</code>) and the server must recognise the client with a unique identifier (like <code>&quot;Alice&quot;</code>). But more concretely, the identifier can be the IP address as well as the port of each of the two peers.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-client_compute" class="anchored"><a href="#val-client_compute" class="anchor"></a><code><span><span class="keyword">val</span> client_compute : 
  <span>client:<a href="#type-client">client</a> <span class="arrow">&#45;&gt;</span></span>
  <span>identity:<span>(string * string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <a href="#type-shared_keys">shared_keys</a> * string, <span>[&gt; <a href="#type-error">error</a> ]</span> )</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>client_compute ~client ~identity:(client, server) _Y client_validator</code> tries to validate <code>_Y</code> and the <code>client_validator</code> with the given <a href="#type-client"><code>client</code></a> information and identities (for more details, about identities, you can look at the note for <a href="#val-server_compute"><code>server_compute</code></a>). It returns <a href="#type-shared_keys"><code>shared_keys</code></a> and the server validator if it succeed. The <code>server_validator</code> should be transmitted to the server.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-server_finalize" class="anchored"><a href="#val-server_finalize" class="anchor"></a><code><span><span class="keyword">val</span> server_finalize : 
  <span>server:<a href="#type-server">server</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <a href="#type-shared_keys">shared_keys</a>, <span>[&gt; <a href="#type-error">error</a> ]</span> )</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>server_finalize ~server server_validator</code> finalizes the handshake and tries to validate the given <code>server_validator</code> with the given <a href="#type-server"><code>server</code></a> information. If it succeed, it returns the <a href="#type-shared_keys"><code>shared_keys</code></a>. Then, the user is able to initiate a secure communication with the given client.</p></div></div></div></body></html>